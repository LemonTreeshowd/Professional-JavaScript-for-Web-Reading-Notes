# 构造函数模式
1. `ECMAScript` 中的构造函数可用来创建特定类型的对象；

2. 有原生构造函数（如 `Object`, `Array` 等），自定义的构造函数；

3. 代码实例
    ```javascript
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function() {
            alert(this.name);
        };
    }

    // 使用
    var yangfch3 = new Person('yangfch3', 21, 'UIDev');
    ```

4. 使用构造函数的几点特殊之处
    * 没有显式地创建对象
    * 直接将属性和方法赋值给 `this`
    * 没有 `return` 语句

5. **约定俗成**：构造函数始终都应该以一个大写字母开头，以示和其他函数的区别；

6. **要创建一个类型的新实例，必须使用 `new` 操作符**；

7. 以 `new` + **构造函数** 的方法创建对象的详细步骤
    1. 创建一个新对象
    2. 将构造函数的作用域赋给新对象（因此 `this` 也就指向了这个新对象）
    3. 执行构造函数中的代码
    4. 返回新对象

8. 同一个类型（构造函数）生成的实例都会有一个 `constructor` 属性指向构造函数
    > 之后我们会指导，其实 `constructor` 是在构造函数的原型上确定的

9. 可以使用 `instanceof` 操作符检验对象的类型；
    > 本质上 `instanceof` 的检测是原型链上 `construtor` 属性的上溯查找

## 1. 将构造函数当做函数
1. 构造函数也是函数，特殊性是 `new` 操作符带来的；
    > 任何函数，只要通过 `new` 操作符调用，那么它就可以作为构造函数；而任何函数，如果不通过 `new` 操作符来调用，那么和普通函数并无二致。

2. 构造函数如果被当做普通函数一样调用（无 `new` 操作符时），属性和方法会被全部添加到全局对象上。

## 2. 构造函数模式的优缺点
1. 优点：
    * 解决了创建同类型代码复用的问题
    * 解决了每个对象的类型归属问题

2. 缺点：
    * 每个方法都要在实例上重新创建一遍
    > 每个方法都指向一个匿名函数，每新建一个实例，就会多创建一个匿名函数，然而这两个匿名函数完成的任务确实一样的，方法与内存的复用性较低[^1]。

## 3. 解决方法复用性的拆东墙补西墙的方法
将对象的方法（函数）定义在全局变量里（构造函数外部），这样全局作用域里的函数由每个实例对象所共享，这样就达到了方法（函数）的复用。

```javascript
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
}

// 将方法（函数）挪到构造函数外
var sayName = function() {
    alert(this.name);
}

// 实例共享方法
var person1 = new Person('yangfch3', 21, 'UIDev');
person1.sayName(); // 'yangfch3'
```

存在的缺陷：

1. 全局作用域变得名副其实（在全局作用域定义的函数只能被对象实例调用）；
2. 当对象的共享方法一多，全局作用域污染明显；
3. 毫无封装性可言，代码毫无美感。

<br>
<br>
[^1]: 理解每个实例都包含一个不同的匿名函数![2016-04-09_214634.jpg-29.7kB][1]


  [1]: http://static.zybuluo.com/yangfch3/g5qmhw3bvtyxsvo0h6903tza/2016-04-09_214634.jpg
