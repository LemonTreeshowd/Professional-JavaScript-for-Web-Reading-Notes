# 垃圾收集
1. `JavaScript` 具有 **自动** 垃圾收集机制 -- 执行环境会负责管理代码执行过程中使用的内存，所需内存的分配以及无用内存的回收完全实现了 **自动化管理**；

2. `C` `C++` 之类的语言，开发人员需要 **手工** 跟踪内存的使用情况；

3. 垃圾收集器按照固定时间间隔（或其他触发条件）周期性的找出那些不再继续使用的变量，然后释放其占用的内存；

4. 垃圾收集器需要跟踪哪个变量有用哪个变量没用，主流的 `JS` 解析器 标识无用变量的策略有两种：**标记清除**、**引用计数**

## 标记清除
1. 标记清除 -- `mark-and-sweep`，最常用的垃圾收集方式；

2. 作用机制
    变量进入机制时，将这个变量标记为“进入环境”，变量离开执行环境（执行流切换至另一函数执行时），则将其标记为“离开环境”

3. `JavaScript` 解析器标记清除垃圾收集的底层实现
    1. 通过**翻转某个特殊的位**来记录一个变量何时进入环境，何时离开环境；
    2. 或者使用一个“进入环境”**变量列表**和一个“离开环境”变量列表来跟踪哪个变量发生了变化；
    3. ...

4. 标记清除实际过程
    1. 解析器先给存储在内存中的所有变量都加上标记（使用任何方式）；
    2. 去掉当前环境中的变量以及被环境中的变量引用的变量的标记；
    3. 执行流离开环境，2 中的变量被打上标记，视为准备删除的变量；
    4. 垃圾收集器完成 **内存清除** 工作，销魂那些带标记的值，回收它们的内存空间。

5. 现代主流浏览器全部采用标记清除的方式进行垃圾收集；

## 引用计数
1. 一种常用的，缺陷比较明显的垃圾收集策略；

2. 引用计数的含义是跟踪记录每个值被引用的额次数；

3. 声明一个变量并将一个引用类型值赋值给变量，则这个值的引用次数就是 1，
如果同一个值又被赋予另一个变量，则该值的引用次数加 1；
相反，如果包含这个对这个值引用的变量又取得另外一个值，则这个值的引用次数减 1；
引用次数变为 0，说明无法再访问这个值，进行内存空间回收。

4. 缺陷：循环引用
    >对象 A 包含一个指向对象 B 的指针，对象 B 包含一个指向对象 A 的引用，A 和 B 对象引用次数永远不会变为 0，导致内存得不到回收；

5. `IE 8-` 一部分对象并不是原生的 `JavaScript` 对象（`IE 9 更正`）；其 `BOM` 和 `DOM` 对象就是使用 `C++` 以 `COM`（Component Object Model 组件对象模型）对象的形式实现的，`COM` 对象的垃圾收集机制采用的就是引用计数策略
    ```javascript
    var element = document.getElementById('some_element');
    var myObject = new Object();

    myObject.elememt = element;
    element.someObject = myObject;
    ```
    上面这段代码在 element DOM 元素与一个原生 `JavaScript` 对象 `myObject` 创建了循环引用，即使将例子中的 `DOM` 从页面移除，也永远不会被回收；

6. 手动断开连接，防止循环引用的方法：指向 `null` 切断引用连接
    ```javascript
    myObject.element = null;
    element.someObject = null;
    ```

## 性能问题
1. 垃圾收集器周期性运行，浏览器厂商确定垃圾回收的时间间隔十分重要；

2. 垃圾收集器还可以是临界值触发的机制；甚至在部分浏览器我们可以使用特定的代码触发运行；

3. `IE 6-` 垃圾回收采用极限触发机制：临界值 -- **256 变量，4096 对象、数组、字面量和数组元素（slot）、64KB 字符串**；导致的问题：面对大型脚本频繁进行垃圾收集，出现严重的性能问题

4. **冷知识**：`IE` 中使用 `window.collectGarbage()` 可触发垃圾收集；`Opera 7+` 中调用 `window.opera.collect()` 也可以触发垃圾收集

## 管理与优化内存
1. 分配给 `Web` 浏览器的可用内存比桌面应用少；

2. **最佳实践**：**优化内存占用的最佳方式** 是为执行中的代码只保存必要的数据，一旦数据不再有用，最好通过将其（引用类型的变量）值设为 `null` 来释放引用；这种方式叫做 -- 解除引用（`dereferencing`）；
    ```javascript
    function createPerson(name) {
        var localPerson = new Object();
        localPerson.name = name;
        return localPerson;
        // localPerson 会在函数运行完后被回收，无需手动解除引用
    }

    var globalPerson = createPerson('yangfch3');
    alert(globalPerson.name);

    globalPerson = null; // 手工解除 globalPerson 的引用

    ```
3. 解除引用的作用是：让值脱离执行环境，以便垃圾收集器运行时将其回收。
